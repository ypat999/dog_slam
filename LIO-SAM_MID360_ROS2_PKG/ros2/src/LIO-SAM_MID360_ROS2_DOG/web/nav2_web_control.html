<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ROS2 Web导航控制</title>
  <!-- 使用简化的依赖，只保留必要的roslib -->
  <script src="libs/roslib.min.js"></script>
  <style>
    body {
      background-color: #1e1e1e;
      color: #eee;
      font-family: "Segoe UI", sans-serif;
      display: flex;
      padding: 10px;
      margin: 0;
      height: calc(100vh - 20px);
      box-sizing: border-box;
    }
    #control-panel {
      width: 300px;
      padding: 10px;
      margin-right: 10px;
      display: flex;
      flex-direction: column;
    }
    #map-container {
      position: relative;
      flex: 1;
      border: 2px solid #555;
      background-color: #2a2a2a;
      overflow: hidden;
      min-width: 0; /* 允许flex子元素收缩 */
    }
    #map-canvas {
      width: 100%;
      height: 100%;
      background-color: #ffffff;
    }
    #robot-marker {
      position: absolute;
      width: 20px;
      height: 20px;
      background-color: #ff0000;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 10;
    }
    #goal-marker {
      position: absolute;
      width: 16px;
      height: 16px;
      background-color: #00ff00;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 5;
    }
    #status {
      margin: 10px;
      font-size: 14px;
    }
    #map-info {
      margin: 10px 0;
      font-size: 12px;
      color: #aaa;
    }
    button {
      background: #3a7bd5;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #2a5fb0;
    }
  </style>
</head>
<body>
  <div id="control-panel">
    <h2>ROS2 网页导航控制</h2>
    <div id="status">连接状态：<span id="conn-status">未连接</span></div>
    <div id="map-info">地图信息：等待连接...</div>
    <div>
      <button onclick="clearGoal()">清除目标</button>
      <button onclick="resetZoom()">重置缩放</button>
    </div>
    <div style="margin-top: 10px;">
      <select id="position-source-select" onchange="changePositionSource(this.value)">
        <option value="amcl">使用AMCL定位</option>
        <option value="lio_sam">使用LIO-SAM里程计</option>
      </select>
      <span id="position-source-status">当前：使用AMCL定位</span>
    </div>
    
    <!-- 地图颜色配置 -->
    <div style="margin-top: 20px; border-top: 1px solid #555; padding-top: 10px;">
      <h3>地图颜色配置</h3>
      <div style="margin-bottom: 8px;">
        <label for="obstacle-color">障碍物颜色：</label>
        <input type="color" id="obstacle-color" value="#000000" onchange="updateMapColor('obstacle', this.value)">
      </div>
      <div style="margin-bottom: 8px;">
        <label for="possible-obstacle-color">可能障碍物：</label>
        <input type="color" id="possible-obstacle-color" value="#444444" onchange="updateMapColor('possibleObstacle', this.value)">
      </div>
      <div style="margin-bottom: 8px;">
        <label for="unknown-color">未知区域：</label>
        <input type="color" id="unknown-color" value="#cccccc" onchange="updateMapColor('unknown', this.value)">
      </div>
      <div style="margin-bottom: 8px;">
        <label for="free-color">自由空间：</label>
        <input type="color" id="free-color" value="#ffffff" onchange="updateMapColor('free', this.value)">
      </div>
    </div>
  </div>
  <div id="map-container">
    <canvas id="map-canvas"></canvas>
    <div id="robot-marker"></div>
    <div id="goal-marker"></div>
  </div>

  <script type="text/javascript">
    // === 配置部分 ===
    const ROSBRIDGE_SERVER_IP = location.hostname; // 自动用当前域名/IP
    const ROSBRIDGE_SERVER_PORT = 9090;
    const MAP_TOPIC = "/map";
    const ROBOT_FRAME = "base_link";
    const LIO_SAM_ODOM_TOPIC = "/lio_sam/mapping/odometry"; // LIO-SAM发布的里程计话题
    const AMCL_POSE_TOPIC = "/amcl_pose"; // AMCL发布的定位话题
    const CMD_TOPIC = "/cmd_vel";
    const GOAL_TOPIC = "/goal_pose";
    // 位置源选择：'lio_sam' 或 'amcl'
    let positionSource = 'amcl'; // 默认使用AMCL定位信息
    
    // 地图颜色配置
    let mapColors = {
      obstacle: '#000000',        // 障碍物颜色 (默认黑色)
      possibleObstacle: '#444444', // 可能障碍物颜色
      unknown: '#cccccc',         // 未知区域颜色
      free: '#ffffff'             // 自由空间颜色
    };
    
    // 地图渲染相关变量
    let canvas, ctx;
    let currentMap = null;
    let robotPosition = { x: 0, y: 0 };
    let goalPosition = null;
    let scale = 1.0; // 缩放比例
    let offsetX = 0; // 偏移量X
    let offsetY = 0; // 偏移量Y
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    // 初始化Canvas
    function initCanvas() {
      canvas = document.getElementById('map-canvas');
      ctx = canvas.getContext('2d');
      
      // 设置Canvas大小为地图容器的完整大小
      const mapContainer = document.getElementById('map-container');
      canvas.width = mapContainer.clientWidth;
      canvas.height = mapContainer.clientHeight;
      
      // 添加鼠标事件处理
      canvas.addEventListener('wheel', handleWheel);
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('mouseleave', handleMouseUp);
      canvas.addEventListener('click', handleCanvasClick);
    }
    
    // 处理鼠标滚轮缩放
    function handleWheel(event) {
      event.preventDefault();
      
      // 获取鼠标在Canvas中的位置
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      // 缩放前的鼠标世界坐标
      const worldX = (mouseX - offsetX) / scale;
      const worldY = (mouseY - offsetY) / scale;
      
      // 调整缩放比例
      const delta = event.deltaY > 0 ? 0.9 : 1.1;
      scale *= delta;
      scale = Math.max(0.1, Math.min(scale, 30)); // 增加最大缩放限制到30
      
      // 调整偏移量，使鼠标指向的点保持不变
      offsetX = mouseX - worldX * scale;
      offsetY = mouseY - worldY * scale;
      
      // 重新绘制地图
      drawMap();
    }
    
    // 处理鼠标按下
    function handleMouseDown(event) {
      isDragging = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
      canvas.style.cursor = 'grabbing';
    }
    
    // 处理鼠标移动（拖动）
    function handleMouseMove(event) {
      if (isDragging) {
        const deltaX = event.clientX - lastMouseX;
        const deltaY = event.clientY - lastMouseY;
        
        offsetX += deltaX;
        offsetY += deltaY;
        
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        
        drawMap();
      }
    }
    
    // 处理鼠标释放
    function handleMouseUp() {
      isDragging = false;
      canvas.style.cursor = 'default';
    }
    
    // 处理Canvas点击事件（设置目标点）
     function handleCanvasClick(event) {
       if (isDragging) return; // 如果正在拖动，则不处理点击
       
       const rect = canvas.getBoundingClientRect();
       const mouseX = event.clientX - rect.left;
       const mouseY = event.clientY - rect.top;
       
       // 转换为地图坐标
       // 从Canvas坐标转换到世界坐标，原点为左下角
       const worldX = (mouseX - offsetX) / scale;
       const worldY = (offsetY - mouseY) / scale;
       
       // 发布目标点
       publishGoal(worldX, worldY);
     }
    
    // 重置缩放和偏移
    function resetZoom() {
      if (currentMap) {
        // 计算合适的缩放比例，与地图初始加载时保持一致
        const mapWidthMeters = currentMap.info.width * currentMap.info.resolution;
        const mapHeightMeters = currentMap.info.height * currentMap.info.resolution;
        
        const scaleX = canvas.width / mapWidthMeters * 0.95;
        const scaleY = canvas.height / mapHeightMeters * 0.95;
        scale = Math.min(scaleX, scaleY);
      } else {
        scale = 1.0; // 如果地图未加载，使用默认值
      }
      
      offsetX = 0; // 原点设在左边界
      offsetY = canvas.height; // 原点设在下边界
      drawMap();
    }
    
    // 绘制地图
     function drawMap() {
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       
       if (!currentMap) {
         // 如果没有地图数据，显示提示信息
         ctx.fillStyle = '#999';
         ctx.font = '16px Arial';
         ctx.textAlign = 'center';
         ctx.textBaseline = 'middle';
         ctx.fillText('等待地图数据...', canvas.width / 2, canvas.height / 2);
         return;
       }
       
       const info = currentMap.info;
       const data = currentMap.data;
       
       // 计算每个格子的大小（像素）
       const cellSize = info.resolution * scale;
       
       // 找到地图中心点（世界坐标）
       const mapCenterX = info.width * info.resolution / 2;
       const mapCenterY = info.height * info.resolution / 2;
       
       // 计算地图绘制的起始位置（Canvas坐标）
       // 不再以中心点计算，而是以左下角为基准
       const startX = offsetX;
       const startY = offsetY - info.height * info.resolution * scale;
       
       // 只绘制可见区域内的格子，提高性能
       const visibleStartCol = Math.max(0, Math.floor(-startX / cellSize));
       const visibleEndCol = Math.min(info.width, Math.ceil((canvas.width - startX) / cellSize) + 1);
       const visibleStartRow = Math.max(0, Math.floor(-startY / cellSize));
       const visibleEndRow = Math.min(info.height, Math.ceil((canvas.height - startY) / cellSize) + 1);
       
       // 绘制可见区域的格子
       // 注意：这里调整了行的遍历顺序，实现地图上下翻转
       for (let row = visibleStartRow; row < visibleEndRow; row++) {
         for (let col = visibleStartCol; col < visibleEndCol; col++) {
           // 计算数组索引时使用翻转的行号，实现地图上下翻转
           const flippedRow = info.height - 1 - row;
           const index = flippedRow * info.width + col;
           const value = data[index];
           
           // 根据占用值设置颜色
           if (value === -1) { // 未知
             ctx.fillStyle = mapColors.unknown;
           } else if (value > 50) { // 障碍物
             ctx.fillStyle = mapColors.obstacle;
           } else if (value > 0) { // 可能障碍物
             ctx.fillStyle = mapColors.possibleObstacle;
           } else { // 自由空间
             ctx.fillStyle = mapColors.free;
           }
           
           // 绘制格子
           const x = startX + col * cellSize;
           const y = startY + row * cellSize;
           ctx.fillRect(x, y, cellSize, cellSize);
           
           // 绘制网格线（仅在缩放级别足够大时）
           if (cellSize > 2) {
             ctx.strokeStyle = '#dddddd';
             ctx.strokeRect(x, y, cellSize, cellSize);
           }
         }
       }
       
       // 绘制原点（现在是左下角）
       ctx.strokeStyle = '#0000ff';
       ctx.lineWidth = 2;
       ctx.beginPath();
       ctx.arc(offsetX, offsetY, 5, 0, 2 * Math.PI);
       ctx.stroke();
       
       // 添加原点标签
       ctx.fillStyle = '#0000ff';
       ctx.font = '12px Arial';
       ctx.textAlign = 'left';
       ctx.textBaseline = 'top';
       ctx.fillText('原点 (0,0)', offsetX + 8, offsetY + 8);
       
       // 绘制机器人位置
       updateRobotMarker();
       
       // 绘制目标位置
       updateGoalMarker();
     }
    
    // 更新机器人标记位置
     function updateRobotMarker() {
       const marker = document.getElementById('robot-marker');
       
       if (currentMap) {
         // 转换世界坐标到Canvas坐标
         // Y坐标计算从原点（左下角）向上延伸
         const canvasX = offsetX + robotPosition.x * scale;
         const canvasY = offsetY - robotPosition.y * scale;
         
         // 设置标记位置
         marker.style.left = canvasX + 'px';
         marker.style.top = canvasY + 'px';
         marker.style.display = 'block';
       } else {
         marker.style.display = 'none';
       }
     }
     
     // 更新目标标记位置
     function updateGoalMarker() {
       const marker = document.getElementById('goal-marker');
       
       if (goalPosition && currentMap) {
         // 转换世界坐标到Canvas坐标
         // Y坐标计算从原点（左下角）向上延伸
         const canvasX = offsetX + goalPosition.x * scale;
         const canvasY = offsetY - goalPosition.y * scale;
         
         // 设置标记位置
         marker.style.left = canvasX + 'px';
         marker.style.top = canvasY + 'px';
         marker.style.display = 'block';
       } else {
         marker.style.display = 'none';
       }
     }
    
    // === 连接 ROS ===
    function connectROS() {
      var ros = new ROSLIB.Ros({
        url: "ws://" + ROSBRIDGE_SERVER_IP + ":" + ROSBRIDGE_SERVER_PORT
      });

      ros.on("connection", function () {
        document.getElementById("conn-status").innerHTML = "✅ 已连接";
        document.getElementById("conn-status").style.color = "#00ff7f";
        console.log('已连接到ROS Bridge服务器');
      });

      ros.on("error", function (error) {
        document.getElementById("conn-status").innerHTML = "❌ 连接错误";
        document.getElementById("conn-status").style.color = "red";
        console.error('ROS Bridge连接错误:', error);
      });

      ros.on("close", function () {
        document.getElementById("conn-status").innerHTML = "⚠️ 已断开";
        document.getElementById("conn-status").style.color = "orange";
        console.log('ROS Bridge连接已关闭');
      });
      
      // 订阅地图主题
      var mapTopic = new ROSLIB.Topic({
        ros: ros,
        name: MAP_TOPIC,
        messageType: 'nav_msgs/OccupancyGrid'
      });
      
      mapTopic.subscribe(function(mapMsg) {
        console.log('收到地图数据:', mapMsg.info.width, 'x', mapMsg.info.height, '分辨率:', mapMsg.info.resolution);
        
        // 更新地图信息显示
        document.getElementById('map-info').innerHTML = `地图信息：${mapMsg.info.width}x${mapMsg.info.height}，分辨率：${mapMsg.info.resolution}m`;
        
        // 保存地图数据
        currentMap = mapMsg;
        
        // 初始调整缩放和偏移，使地图以左下角为原点
        const mapWidthMeters = mapMsg.info.width * mapMsg.info.resolution;
        const mapHeightMeters = mapMsg.info.height * mapMsg.info.resolution;
        
        // 计算合适的初始缩放比例
        const scaleX = canvas.width / mapWidthMeters * 0.95; // 增加初始缩放比例
        const scaleY = canvas.height / mapHeightMeters * 0.95;
        scale = Math.min(scaleX, scaleY);
        
        // 设置原点为左下角
        offsetX = 0;
        offsetY = canvas.height;
        
        // 绘制地图
        drawMap();
      });
      
      // 订阅LIO-SAM里程计主题
      var lioSamOdomTopic = new ROSLIB.Topic({
        ros: ros,
        name: LIO_SAM_ODOM_TOPIC,
        messageType: 'nav_msgs/Odometry'
      });
      
      lioSamOdomTopic.subscribe(function(odomMsg) {
        // 只有当位置源设置为lio_sam时才使用这些数据
        if (positionSource === 'lio_sam') {
          // 更新机器人位置
          robotPosition.x = odomMsg.pose.pose.position.x;
          // 注意：这里保持原始Y坐标，因为在updateRobotMarker中已经处理了翻转
          robotPosition.y = odomMsg.pose.pose.position.y;
          
          // 重绘地图以更新机器人位置
          drawMap();
        }
      });
      
      // 订阅AMCL位置主题
      var amclPoseTopic = new ROSLIB.Topic({
        ros: ros,
        name: AMCL_POSE_TOPIC,
        messageType: 'geometry_msgs/PoseWithCovarianceStamped'
      });
      
      amclPoseTopic.subscribe(function(poseMsg) {
        // 只有当位置源设置为amcl时才使用这些数据
        if (positionSource === 'amcl') {
          // 更新机器人位置
          robotPosition.x = poseMsg.pose.pose.position.x;
          // 注意：这里保持原始Y坐标，因为在updateRobotMarker中已经处理了翻转
          robotPosition.y = poseMsg.pose.pose.position.y;
          
          // 重绘地图以更新机器人位置
          drawMap();
        }
      });
      
      return ros;
    }
    
    // 发布目标点
    function publishGoal(x, y) {
      if (!window.ros || !currentMap) {
        alert('请先确保ROS连接正常且已收到地图数据');
        return;
      }
      
      // 保存目标位置用于显示
      goalPosition = { x: x, y: y };
      
      // 创建目标发布器（如果还没有）
      if (!window.goalPublisher) {
        window.goalPublisher = new ROSLIB.Topic({
          ros: window.ros,
          name: GOAL_TOPIC,
          messageType: "geometry_msgs/PoseStamped"
        });
      }
      
      // 创建目标消息
      const now = Date.now() / 1000.0;
      var goal = new ROSLIB.Message({
        header: {
          stamp: { 
            sec: Math.floor(now), 
            nanosec: Math.floor((now % 1) * 1e9) // 修复：确保nanosec是整数类型
          },
          frame_id: "map"
        },
        pose: {
          position: { x: x, y: y, z: 0 },
          orientation: { x: 0, y: 0, z: 0, w: 1 } // 默认朝向
        }
      });
      
      // 发布目标
      window.goalPublisher.publish(goal);
      console.log('发布目标点:', goal);
      
      // 更新目标标记
      updateGoalMarker();
    }
    
    // 清除目标点
    function clearGoal() {
      // 在ROS2中，取消导航目标需要发布到取消话题
      if (!window.ros) {
        alert('请先确保ROS连接正常');
        return;
      }
      
      try {
        // 方法1：发布到导航取消话题
        // 创建取消发布器（如果还没有）
        if (!window.cancelPublisher) {
          window.cancelPublisher = new ROSLIB.Topic({
            ros: window.ros,
            name: "/navigate_to_pose/_action/cancel",
            messageType: "action_msgs/GoalID"
          });
        }
        
        // 发布取消消息
        const cancelMsg = new ROSLIB.Message({
          stamp: { 
            sec: Math.floor(Date.now() / 1000), 
            nanosec: Math.floor((Date.now() % 1000) * 1e6)
          },
          id: "" // 空ID表示取消所有目标
        });
        
        window.cancelPublisher.publish(cancelMsg);
        console.log('已发送导航目标取消请求');
        
        // 方法2：发布零速度命令让机器人停止
        if (!window.cmdVelPublisher) {
          window.cmdVelPublisher = new ROSLIB.Topic({
            ros: window.ros,
            name: CMD_TOPIC,
            messageType: 'geometry_msgs/Twist'
          });
        }
        
        // 发送零速度命令
        const stopCmd = new ROSLIB.Message({
          linear: { x: 0, y: 0, z: 0 },
          angular: { x: 0, y: 0, z: 0 }
        });
        
        window.cmdVelPublisher.publish(stopCmd);
         console.log('已发送停止命令');
         
         // 方法3：尝试发布到行为树取消话题（备用方法）
         try {
           if (!window.btCancelPublisher) {
             window.btCancelPublisher = new ROSLIB.Topic({
               ros: window.ros,
               name: "/behavior_tree/cancel",
               messageType: "action_msgs/GoalID"
             });
           }
           
           const btCancelMsg = new ROSLIB.Message({
             stamp: { 
               sec: Math.floor(Date.now() / 1000), 
               nanosec: Math.floor((Date.now() % 1000) * 1e6)
             },
             id: ""
           });
           
           window.btCancelPublisher.publish(btCancelMsg);
           console.log('已发送行为树取消请求');
         } catch (btError) {
           console.warn('行为树取消失败（可选方法）:', btError);
         }
         
         // 隐藏目标标记
         goalPosition = null;
         updateGoalMarker();
        
        alert('已取消导航目标并停止机器人');
        
      } catch (error) {
        console.error('取消目标时出错:', error);
        alert('取消目标失败，请检查ROS连接');
      }
    }
    
    // 切换位置源
    function changePositionSource(source) {
      positionSource = source;
      // 更新状态显示
      const statusElement = document.getElementById('position-source-status');
      if (source === 'amcl') {
        statusElement.textContent = '当前：使用AMCL定位';
      } else if (source === 'lio_sam') {
        statusElement.textContent = '当前：使用LIO-SAM里程计';
      }
      console.log('位置源已切换为:', source);
      // 切换位置源后，可能需要等待新数据到来才能更新显示
    }
    
    // 更新地图颜色
    function updateMapColor(colorType, colorValue) {
      mapColors[colorType] = colorValue;
      console.log(`已更新${colorType}颜色为:`, colorValue);
      // 重新绘制地图以应用新颜色
      drawMap();
    }
    
    // 页面加载完成后初始化
    window.onload = function() {
      initCanvas();
      window.ros = connectROS();
      
      // 窗口大小改变时重新设置Canvas大小
      window.addEventListener('resize', function() {
        const mapContainer = document.getElementById('map-container');
        canvas.width = mapContainer.clientWidth;
        canvas.height = mapContainer.clientHeight;
        drawMap();
      });
    };
  </script>
</body>
</html>
