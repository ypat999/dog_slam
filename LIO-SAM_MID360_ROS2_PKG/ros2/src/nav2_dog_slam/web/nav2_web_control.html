<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ROS2 Webå¯¼èˆªæ§åˆ¶</title>
  <!-- ä½¿ç”¨ç®€åŒ–çš„ä¾èµ–ï¼Œåªä¿ç•™å¿…è¦çš„roslib -->
  <script src="libs/roslib.min.js"></script>
  <style>
    body {
      background-color: #1e1e1e;
      color: #eee;
      font-family: "Segoe UI", sans-serif;
      display: flex;
      padding: 10px;
      margin: 0;
      height: calc(100vh - 20px);
      box-sizing: border-box;
    }
    #control-panel {
      width: 300px;
      padding: 10px;
      margin-right: 10px;
      display: flex;
      flex-direction: column;
    }
    #map-container {
      position: relative;
      flex: 1;
      border: 2px solid #555;
      background-color: #2a2a2a;
      overflow: hidden;
      min-width: 0; /* å…è®¸flexå­å…ƒç´ æ”¶ç¼© */
    }
    #map-canvas {
      width: 100%;
      height: 100%;
      background-color: #ffffff;
    }
    .marker {
      background: none;
      border: none;
      outline: none;
      box-shadow: none;
      border-radius: 0;
      padding: 0;
      margin: 0;
      content: "";
    }
    
    #robot-marker {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 20px solid #ff0000;
      transform: translate(-50%, -50%) rotate(0deg);
      display: none;
      z-index: 10;
    }
    #goal-marker {
      position: absolute;
      width: 16px;
      height: 16px;
      background-color: #00ff00;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 5;
    }
    #initial-pose-marker {
      position: absolute;
      width: 18px;
      height: 18px;
      background-color: #ff8800;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 6;
      border: 2px solid #ffffff;
    }
    #status {
      margin: 10px;
      font-size: 14px;
    }
    #map-info {
      margin: 10px 0;
      font-size: 12px;
      color: #aaa;
    }
    button {
      background: #3a7bd5;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #2a5fb0;
    }
  </style>
</head>
<body>
  <div id="control-panel">
    <h2>ROS2 ç½‘é¡µå¯¼èˆªæ§åˆ¶</h2>
    <div id="status">è¿æ¥çŠ¶æ€ï¼š<span id="conn-status">æœªè¿æ¥</span></div>
    <div id="map-info">åœ°å›¾ä¿¡æ¯ï¼šç­‰å¾…è¿æ¥...</div>
    
    <!-- ä¸»æœºåé…ç½® -->
    <div style="margin-top: 10px; margin-bottom: 10px;">
      <label for="hostname-input">ROSä¸»æœºå/IPï¼š</label>
      <input type="text" id="hostname-input" value="" placeholder="ç•™ç©ºä½¿ç”¨å½“å‰ä¸»æœº" style="width: 150px; padding: 4px; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;">
      <button onclick="updateHostname()" style="margin-left: 5px; padding: 4px 8px; font-size: 12px;">æ›´æ–°</button>
    </div>
    <div>
      <button onclick="clearGoal()">æ¸…é™¤ç›®æ ‡</button>
      <button onclick="resetZoom()">é‡ç½®ç¼©æ”¾</button>
      <div style="margin-top: 5px;">
        <label for="goal-yaw">ç›®æ ‡ç‚¹æœå‘(yaw)ï¼š</label>
        <input type="number" id="goal-yaw" value="0" min="-180" max="180" step="1" style="width: 60px; padding: 2px; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;">Â°
      </div>
      <div style="margin-top: 5px; font-size: 12px; color: #aaa;">
        æ“ä½œæç¤ºï¼šåœ¨åœ°å›¾ä¸Šç‚¹å‡»å¹¶æ‹–åŠ¨æ¥è®¾ç½®ç›®æ ‡ä½ç½®å’Œæ–¹å‘
      </div>
    </div>
    <div style="margin-top: 10px;">
      <button onclick="setInitialPose()">è®¾ç½®åˆå§‹ç‚¹</button>
      <button onclick="clearInitialPose()">æ¸…é™¤åˆå§‹ç‚¹</button>
      <span id="initial-pose-status">æœªè®¾ç½®</span>
      <div style="margin-top: 5px;">
        <label for="initial-pose-yaw">åˆå§‹ç‚¹æœå‘(yaw)ï¼š</label>
        <input type="number" id="initial-pose-yaw" value="0" min="-180" max="180" step="1" style="width: 60px; padding: 2px; background: #333; color: #fff; border: 1px solid #555; border-radius: 3px;">Â°
      </div>
      <div style="margin-top: 5px; font-size: 12px; color: #aaa;">
        æ“ä½œæç¤ºï¼šç‚¹å‡»"è®¾ç½®åˆå§‹ç‚¹"æŒ‰é’®åï¼Œåœ¨åœ°å›¾ä¸Šç‚¹å‡»å¹¶æ‹–åŠ¨æ¥è®¾ç½®ä½ç½®å’Œæ–¹å‘
      </div>
    </div>
    <div style="margin-top: 10px;">
      <select id="position-source-select" onchange="changePositionSource(this.value)">
        <option value="amcl">ä½¿ç”¨AMCLå®šä½</option>
        <option value="slam_toolbox">ä½¿ç”¨slam_toolboxå®šä½</option>
        <option value="lio_sam">ä½¿ç”¨LIO-SAMé‡Œç¨‹è®¡</option>
      </select>
  <span id="position-source-status">å½“å‰ï¼šä½¿ç”¨AMCLå®šä½</span>
    </div>
    
    <!-- åœ°å›¾é¢œè‰²é…ç½® -->
    <div style="margin-top: 20px; border-top: 1px solid #555; padding-top: 10px;">
      <h3>åœ°å›¾é¢œè‰²é…ç½®</h3>
      <div style="margin-bottom: 8px;">
        <label for="obstacle-color">éšœç¢ç‰©é¢œè‰²ï¼š</label>
        <input type="color" id="obstacle-color" value="#000000" onchange="updateMapColor('obstacle', this.value)">
      </div>
      <div style="margin-bottom: 8px;">
        <label for="possible-obstacle-color">å¯èƒ½éšœç¢ç‰©ï¼š</label>
        <input type="color" id="possible-obstacle-color" value="#444444" onchange="updateMapColor('possibleObstacle', this.value)">
      </div>
      <div style="margin-bottom: 8px;">
        <label for="unknown-color">æœªçŸ¥åŒºåŸŸï¼š</label>
        <input type="color" id="unknown-color" value="#cccccc" onchange="updateMapColor('unknown', this.value)">
      </div>
      <div style="margin-bottom: 8px;">
        <label for="free-color">è‡ªç”±ç©ºé—´ï¼š</label>
        <input type="color" id="free-color" value="#ffffff" onchange="updateMapColor('free', this.value)">
      </div>
    </div>
  </div>
  <div id="map-container">
    <canvas id="map-canvas"></canvas>
    <div id="robot-marker" class="marker"></div>
    <div id="goal-marker" class="marker"></div>
    <div id="initial-pose-marker" class="marker"></div>
  </div>

  <script type="text/javascript">
    // === é…ç½®éƒ¨åˆ† ===
    let ROSBRIDGE_SERVER_IP = localStorage.getItem('ros_hostname') || location.hostname; // ä¼˜å…ˆä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„ä¸»æœºå
    const ROSBRIDGE_SERVER_PORT = 9090;
    const MAP_TOPIC = "/map";
    const ROBOT_FRAME = "base_link";
    const LIO_SAM_ODOM_TOPIC = "/lio_sam/mapping/odometry"; // LIO-SAMå‘å¸ƒçš„é‡Œç¨‹è®¡è¯é¢˜
  const AMCL_POSE_TOPIC = "/amcl_pose"; // AMCLå‘å¸ƒçš„å®šä½è¯é¢˜
  const SLAM_TOOLBOX_POSE_TOPIC = "/slam_toolbox_pose"; // slam_toolbox å¸¸è§çš„å®šä½è¯é¢˜ï¼ˆè‹¥ä½ çš„ç‰ˆæœ¬æˆ–é…ç½®ä¸åŒï¼Œè¯·æ ¹æ®å®é™…topicè°ƒæ•´ï¼‰
    const CMD_TOPIC = "/cmd_vel";
    const GOAL_TOPIC = "/goal_pose";
    const INITIAL_POSE_TOPIC = "/initialpose";
  // ä½ç½®æºé€‰æ‹©ï¼š'lio_sam' æˆ– 'amcl' æˆ– 'slam_toolbox'
  let positionSource = 'amcl'; // é»˜è®¤ä½¿ç”¨AMCLå®šä½ä¿¡æ¯
    
    // åœ°å›¾é¢œè‰²é…ç½®
    let mapColors = {
      obstacle: '#000000',        // éšœç¢ç‰©é¢œè‰² (é»˜è®¤é»‘è‰²)
      possibleObstacle: '#444444', // å¯èƒ½éšœç¢ç‰©é¢œè‰²
      unknown: '#cccccc',         // æœªçŸ¥åŒºåŸŸé¢œè‰²
      free: '#ffffff'             // è‡ªç”±ç©ºé—´é¢œè‰²
    };
    
    // åœ°å›¾æ¸²æŸ“ç›¸å…³å˜é‡
    let canvas, ctx;
    let currentMap = null;
    let robotPosition = { x: 0, y: 0, theta: 0 }; // æ·»åŠ thetaè¡¨ç¤ºæœºå™¨äººæœå‘
    let goalPosition = null;
    let initialPosePosition = null;
    let scale = 1.0; // ç¼©æ”¾æ¯”ä¾‹
    let offsetX = 0; // åç§»é‡X
    let offsetY = 0; // åç§»é‡Y
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    // åˆå§‹åŒ–Canvas
    function initCanvas() {
      canvas = document.getElementById('map-canvas');
      ctx = canvas.getContext('2d');
      
      // è®¾ç½®Canvaså¤§å°ä¸ºåœ°å›¾å®¹å™¨çš„å®Œæ•´å¤§å°
      const mapContainer = document.getElementById('map-container');
      canvas.width = mapContainer.clientWidth;
      canvas.height = mapContainer.clientHeight;
      
      // æ·»åŠ é¼ æ ‡äº‹ä»¶å¤„ç† - åªä¿ç•™ç¼©æ”¾åŠŸèƒ½ï¼Œç¦ç”¨æ‹–åŠ¨
      canvas.addEventListener('wheel', handleWheel);
      canvas.addEventListener('click', handleCanvasClick);
      
      // æ·»åŠ æ–¹å‘è®¾ç½®ç›¸å…³çš„äº‹ä»¶å¤„ç†
      canvas.addEventListener('mousedown', handleMouseDownForDirection);
      canvas.addEventListener('mousemove', handleMouseMoveForDirection);
      canvas.addEventListener('mouseup', handleMouseUpForDirection);
    }

    // æ›´æ–°ä¸»æœºå
    function updateHostname() {
      const hostnameInput = document.getElementById('hostname-input');
      const newHostname = hostnameInput.value.trim();
      
      if (newHostname === '') {
        ROSBRIDGE_SERVER_IP = location.hostname;
        localStorage.removeItem('ros_hostname'); // æ¸…é™¤æœ¬åœ°å­˜å‚¨
        alert('å·²é‡ç½®ä¸ºå½“å‰ä¸»æœºåï¼š' + location.hostname + '\nè®¾ç½®å·²ä¿å­˜ï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆ');
      } else {
        ROSBRIDGE_SERVER_IP = newHostname;
        localStorage.setItem('ros_hostname', newHostname); // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        alert('å·²æ›´æ–°ä¸»æœºåä¸ºï¼š' + newHostname + '\nè®¾ç½®å·²ä¿å­˜ï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆ');
      }
      
      // æ›´æ–°è¾“å…¥æ¡†æ˜¾ç¤º
      hostnameInput.value = ROSBRIDGE_SERVER_IP === location.hostname ? '' : ROSBRIDGE_SERVER_IP;
      
      console.log('ROSä¸»æœºåå·²æ›´æ–°ä¸ºï¼š', ROSBRIDGE_SERVER_IP);
      
      // æ˜¾ç¤ºé‡æ–°è¿æ¥æç¤º
      document.getElementById('conn-status').innerHTML = "ğŸ”„ éœ€è¦åˆ·æ–°é¡µé¢";
      document.getElementById('conn-status').style.color = "#ffa500";
    }

    // åˆå§‹åŒ–ä¸»æœºåè¾“å…¥æ¡†
    function initHostnameInput() {
      const hostnameInput = document.getElementById('hostname-input');
      const savedHostname = localStorage.getItem('ros_hostname');
      
      if (savedHostname) {
        // å¦‚æœæœ‰ä¿å­˜çš„ä¸»æœºåï¼Œæ˜¾ç¤ºå®ƒ
        hostnameInput.value = savedHostname;
      } else if (ROSBRIDGE_SERVER_IP !== location.hostname) {
        // å¦‚æœå½“å‰ä¸»æœºåä¸æ˜¯é»˜è®¤çš„ï¼Œæ˜¾ç¤ºå½“å‰ä¸»æœºå
        hostnameInput.value = ROSBRIDGE_SERVER_IP;
      } else {
        // å¦åˆ™ç•™ç©ºï¼ˆä½¿ç”¨é»˜è®¤ä¸»æœºåï¼‰
        hostnameInput.value = '';
      }
    }
    
    // å¤„ç†é¼ æ ‡æ»šè½®ç¼©æ”¾
    function handleWheel(event) {
      event.preventDefault();
      
      // è·å–é¼ æ ‡åœ¨Canvasä¸­çš„ä½ç½®
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      // ç¼©æ”¾å‰çš„é¼ æ ‡ä¸–ç•Œåæ ‡
      const worldX = (mouseX - offsetX) / scale;
      const worldY = (mouseY - offsetY) / scale;
      
      // è°ƒæ•´ç¼©æ”¾æ¯”ä¾‹
      const delta = event.deltaY > 0 ? 0.9 : 1.1;
      scale *= delta;
      scale = Math.max(0.1, Math.min(scale, 30)); // å¢åŠ æœ€å¤§ç¼©æ”¾é™åˆ¶åˆ°30
      
      // è°ƒæ•´åç§»é‡ï¼Œä½¿é¼ æ ‡æŒ‡å‘çš„ç‚¹ä¿æŒä¸å˜
      offsetX = mouseX - worldX * scale;
      offsetY = mouseY - worldY * scale;
      
      // é‡æ–°ç»˜åˆ¶åœ°å›¾
      drawMap();
    }
    

    
    // å¤„ç†Canvasç‚¹å‡»äº‹ä»¶ï¼ˆè®¾ç½®ç›®æ ‡ç‚¹æˆ–åˆå§‹ç‚¹ï¼‰
     function handleCanvasClick(event) {
       // å¦‚æœæ­£åœ¨è®¾ç½®æ–¹å‘ï¼Œåˆ™ä¸å¤„ç†ç‚¹å‡»äº‹ä»¶
       if (isSettingDirection) return;
       
       const rect = canvas.getBoundingClientRect();
       const mouseX = event.clientX - rect.left;
       const mouseY = event.clientY - rect.top;
       
       // è½¬æ¢ä¸ºåœ°å›¾åæ ‡
       const worldX = (mouseX - offsetX) / scale;
       const worldY = (offsetY - mouseY) / scale;
       
       if (window.settingInitialPose) {
         // åœ¨è®¾ç½®åˆå§‹ç‚¹æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»å³è®¾ç½®åˆå§‹ç‚¹ï¼ˆæ— æ–¹å‘ï¼‰
         publishInitialPose(worldX, worldY, 0);
         window.settingInitialPose = false;
         canvas.style.cursor = 'default';
         
         // æ¢å¤æŒ‰é’®çŠ¶æ€
         const setInitialPoseButton = document.querySelector('button[onclick="setInitialPose()"]');
         if (setInitialPoseButton) {
           setInitialPoseButton.textContent = 'è®¾ç½®åˆå§‹ç‚¹';
           setInitialPoseButton.onclick = setInitialPose;
         }
       } else {
         // æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»å³è®¾ç½®ç›®æ ‡ç‚¹ï¼ˆæ— æ–¹å‘ï¼‰
         publishGoal(worldX, worldY, 0);
       }
     }
     
     // æ·»åŠ é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ç”¨äºæ‹–åŠ¨è®¾ç½®æ–¹å‘
     let dragStartX, dragStartY, isSettingDirection = false;
     
     function handleMouseDownForDirection(event) {
       // åªæœ‰åœ¨è®¾ç½®åˆå§‹ç‚¹æ¨¡å¼ä¸‹æˆ–è€…æŒ‰ä½Ctrl/Shifté”®æ—¶æ‰å¯ç”¨æ–¹å‘è®¾ç½®
       if (window.settingInitialPose || event.ctrlKey || event.shiftKey) {
         // æ£€æŸ¥æ˜¯å¦æ˜¯åœ¨åœ°å›¾ä¸Šç‚¹å‡»ï¼ˆè€Œä¸æ˜¯åœ¨æ§ä»¶ä¸Šï¼‰
         const rect = canvas.getBoundingClientRect();
         const mouseX = event.clientX - rect.left;
         const mouseY = event.clientY - rect.top;
         
         // è½¬æ¢ä¸ºåœ°å›¾åæ ‡
         const worldX = (mouseX - offsetX) / scale;
         const worldY = (offsetY - mouseY) / scale;
         
         // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
         if (currentMap) {
           const mapWidth = currentMap.info.width * currentMap.info.resolution;
           const mapHeight = currentMap.info.height * currentMap.info.resolution;
           
           if (worldX >= 0 && worldX <= mapWidth && worldY >= 0 && worldY <= mapHeight) {
             dragStartX = event.clientX - rect.left;
             dragStartY = event.clientY - rect.top;
             isSettingDirection = true;
             canvas.style.cursor = 'crosshair';
             event.preventDefault();
           }
         }
       }
     }
     
     function handleMouseMoveForDirection(event) {
       if (isSettingDirection) {
         // æ·»åŠ è§†è§‰åé¦ˆï¼Œæ˜¾ç¤ºä¸€æ¡çº¿è¡¨ç¤ºæ–¹å‘
         // æ¸…é™¤ä¹‹å‰çš„ç»˜åˆ¶
         drawMap();
         
         // ç»˜åˆ¶æ–¹å‘çº¿
         const rect = canvas.getBoundingClientRect();
         const currentX = event.clientX - rect.left;
         const currentY = event.clientY - rect.top;
         
         ctx.beginPath();
         ctx.moveTo(dragStartX, dragStartY);
         ctx.lineTo(currentX, currentY);
         ctx.strokeStyle = '#ff0000';
         ctx.lineWidth = 2;
         ctx.stroke();
         
         // ç»˜åˆ¶ç®­å¤´å¤´éƒ¨
         const angle = Math.atan2(currentY - dragStartY, currentX - dragStartX);
         const arrowSize = 10;
         
         ctx.beginPath();
         ctx.moveTo(currentX, currentY);
         ctx.lineTo(
           currentX - arrowSize * Math.cos(angle - Math.PI/6),
           currentY - arrowSize * Math.sin(angle - Math.PI/6)
         );
         ctx.moveTo(currentX, currentY);
         ctx.lineTo(
           currentX - arrowSize * Math.cos(angle + Math.PI/6),
           currentY - arrowSize * Math.sin(angle + Math.PI/6)
         );
         ctx.stroke();
         
         event.preventDefault();
       }
     }
     
     function handleMouseUpForDirection(event) {
       if (isSettingDirection) {
         const rect = canvas.getBoundingClientRect();
         const endX = event.clientX - rect.left;
         const endY = event.clientY - rect.top;
         
         // åªæœ‰å½“æ‹–åŠ¨è·ç¦»è¶³å¤Ÿå¤§æ—¶æ‰è®¾ç½®æ–¹å‘
         const distance = Math.sqrt(Math.pow(endX - dragStartX, 2) + Math.pow(endY - dragStartY, 2));
         if (distance > 5) { // è‡³å°‘æ‹–åŠ¨5åƒç´ æ‰è®¤ä¸ºæ˜¯æœ‰æ•ˆçš„æ–¹å‘è®¾ç½®
           // è½¬æ¢ä¸ºåœ°å›¾åæ ‡
           const startX = (dragStartX - offsetX) / scale;
           const startY = (offsetY - dragStartY) / scale;
           const endXWorld = (endX - offsetX) / scale;
           const endYWorld = (offsetY - endY) / scale;
           
           // è®¡ç®—æ–¹å‘è§’åº¦
           const dx = endXWorld - startX;
           const dy = endYWorld - startY;
           const angle = Math.atan2(dy, dx);
           
           // æ ¹æ®å½“å‰æ¨¡å¼å†³å®šæ˜¯è®¾ç½®ç›®æ ‡ç‚¹è¿˜æ˜¯åˆå§‹ç‚¹
           if (window.settingInitialPose) {
             // è®¾ç½®åˆå§‹ç‚¹æ¨¡å¼
             publishInitialPose(startX, startY, angle);
             window.settingInitialPose = false;
             canvas.style.cursor = 'default';
             
             // æ¢å¤æŒ‰é’®çŠ¶æ€
             const setInitialPoseButton = document.querySelector('button[onclick="setInitialPose()"]');
             if (setInitialPoseButton) {
               setInitialPoseButton.textContent = 'è®¾ç½®åˆå§‹ç‚¹';
               setInitialPoseButton.onclick = setInitialPose;
             }
           } else {
             // æ­£å¸¸æ¨¡å¼ - è®¾ç½®ç›®æ ‡ç‚¹
             publishGoal(startX, startY, angle);
           }
         } else {
           // å¦‚æœæ‹–åŠ¨è·ç¦»å¤ªå°ï¼Œå°±å½“ä½œæ™®é€šç‚¹å‡»å¤„ç†
           const worldX = (dragStartX - offsetX) / scale;
           const worldY = (offsetY - dragStartY) / scale;
           
           if (window.settingInitialPose) {
             // è®¾ç½®åˆå§‹ç‚¹æ¨¡å¼
             publishInitialPose(worldX, worldY, 0);
             window.settingInitialPose = false;
             canvas.style.cursor = 'default';
             
             // æ¢å¤æŒ‰é’®çŠ¶æ€
             const setInitialPoseButton = document.querySelector('button[onclick="setInitialPose()"]');
             if (setInitialPoseButton) {
               setInitialPoseButton.textContent = 'è®¾ç½®åˆå§‹ç‚¹';
               setInitialPoseButton.onclick = setInitialPose;
             }
           } else {
             // æ­£å¸¸æ¨¡å¼ - è®¾ç½®ç›®æ ‡ç‚¹
             publishGoal(worldX, worldY, 0);
           }
         }
         
         isSettingDirection = false;
         canvas.style.cursor = 'default';
         drawMap(); // é‡æ–°ç»˜åˆ¶åœ°å›¾ä»¥æ¸…é™¤æ–¹å‘çº¿
         event.preventDefault();
       }
     }
    
    // é‡ç½®ç¼©æ”¾å’Œåç§»
    function resetZoom() {
      if (currentMap) {
        // è®¡ç®—åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹ï¼Œä¸åœ°å›¾åˆå§‹åŠ è½½æ—¶ä¿æŒä¸€è‡´
        const mapWidthMeters = currentMap.info.width * currentMap.info.resolution;
        const mapHeightMeters = currentMap.info.height * currentMap.info.resolution;
        
        const scaleX = canvas.width / mapWidthMeters * 0.95;
        const scaleY = canvas.height / mapHeightMeters * 0.95;
        scale = Math.min(scaleX, scaleY);
      } else {
        scale = 1.0; // å¦‚æœåœ°å›¾æœªåŠ è½½ï¼Œä½¿ç”¨é»˜è®¤å€¼
      }
      
      offsetX = 0; // åŸç‚¹è®¾åœ¨å·¦è¾¹ç•Œ
      offsetY = canvas.height; // åŸç‚¹è®¾åœ¨ä¸‹è¾¹ç•Œ
      drawMap();
    }
    
    // ç»˜åˆ¶åœ°å›¾
     function drawMap() {
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       
       if (!currentMap) {
         // å¦‚æœæ²¡æœ‰åœ°å›¾æ•°æ®ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
         ctx.fillStyle = '#999';
         ctx.font = '16px Arial';
         ctx.textAlign = 'center';
         ctx.textBaseline = 'middle';
         ctx.fillText('ç­‰å¾…åœ°å›¾æ•°æ®...', canvas.width / 2, canvas.height / 2);
         return;
       }
       
       const info = currentMap.info;
       const data = currentMap.data;
       
       // è®¡ç®—æ¯ä¸ªæ ¼å­çš„å¤§å°ï¼ˆåƒç´ ï¼‰
       const cellSize = info.resolution * scale;
       
       // æ‰¾åˆ°åœ°å›¾ä¸­å¿ƒç‚¹ï¼ˆä¸–ç•Œåæ ‡ï¼‰
       const mapCenterX = info.width * info.resolution / 2;
       const mapCenterY = info.height * info.resolution / 2;
       
       // è®¡ç®—åœ°å›¾ç»˜åˆ¶çš„èµ·å§‹ä½ç½®ï¼ˆCanvasåæ ‡ï¼‰
       // ä¸å†ä»¥ä¸­å¿ƒç‚¹è®¡ç®—ï¼Œè€Œæ˜¯ä»¥å·¦ä¸‹è§’ä¸ºåŸºå‡†
       const startX = offsetX;
       const startY = offsetY - info.height * info.resolution * scale;
       
       // åªç»˜åˆ¶å¯è§åŒºåŸŸå†…çš„æ ¼å­ï¼Œæé«˜æ€§èƒ½
       const visibleStartCol = Math.max(0, Math.floor(-startX / cellSize));
       const visibleEndCol = Math.min(info.width, Math.ceil((canvas.width - startX) / cellSize) + 1);
       const visibleStartRow = Math.max(0, Math.floor(-startY / cellSize));
       const visibleEndRow = Math.min(info.height, Math.ceil((canvas.height - startY) / cellSize) + 1);
       
       // ç»˜åˆ¶å¯è§åŒºåŸŸçš„æ ¼å­
       // æ³¨æ„ï¼šè¿™é‡Œè°ƒæ•´äº†è¡Œçš„éå†é¡ºåºï¼Œå®ç°åœ°å›¾ä¸Šä¸‹ç¿»è½¬
       for (let row = visibleStartRow; row < visibleEndRow; row++) {
         for (let col = visibleStartCol; col < visibleEndCol; col++) {
           // è®¡ç®—æ•°ç»„ç´¢å¼•æ—¶ä½¿ç”¨ç¿»è½¬çš„è¡Œå·ï¼Œå®ç°åœ°å›¾ä¸Šä¸‹ç¿»è½¬
           const flippedRow = info.height - 1 - row;
           const index = flippedRow * info.width + col;
           const value = data[index];
           
           // æ ¹æ®å ç”¨å€¼è®¾ç½®é¢œè‰²
           if (value === -1) { // æœªçŸ¥
             ctx.fillStyle = mapColors.unknown;
           } else if (value > 50) { // éšœç¢ç‰©
             ctx.fillStyle = mapColors.obstacle;
           } else if (value > 0) { // å¯èƒ½éšœç¢ç‰©
             ctx.fillStyle = mapColors.possibleObstacle;
           } else { // è‡ªç”±ç©ºé—´
             ctx.fillStyle = mapColors.free;
           }
           
           // ç»˜åˆ¶æ ¼å­
           const x = startX + col * cellSize;
           const y = startY + row * cellSize;
           ctx.fillRect(x, y, cellSize, cellSize);
           
           // ç»˜åˆ¶ç½‘æ ¼çº¿ï¼ˆä»…åœ¨ç¼©æ”¾çº§åˆ«è¶³å¤Ÿå¤§æ—¶ï¼‰
           if (cellSize > 2) {
             ctx.strokeStyle = '#dddddd';
             ctx.strokeRect(x, y, cellSize, cellSize);
           }
         }
       }
       
       // ç»˜åˆ¶åŸç‚¹ï¼ˆç°åœ¨æ˜¯å·¦ä¸‹è§’ï¼‰
       ctx.strokeStyle = '#0000ff';
       ctx.lineWidth = 2;
       ctx.beginPath();
       ctx.arc(offsetX, offsetY, 5, 0, 2 * Math.PI);
       ctx.stroke();
       
       // æ·»åŠ åŸç‚¹æ ‡ç­¾
       ctx.fillStyle = '#0000ff';
       ctx.font = '12px Arial';
       ctx.textAlign = 'left';
       ctx.textBaseline = 'top';
       ctx.fillText('åŸç‚¹ (0,0)', offsetX + 8, offsetY + 8);
       
       // ç»˜åˆ¶æœºå™¨äººä½ç½®
       updateRobotMarker();
       
       // ç»˜åˆ¶ç›®æ ‡ä½ç½®
       updateGoalMarker();
       
       // æ›´æ–°åˆå§‹ç‚¹æ ‡è®°
       updateInitialPoseMarker();
     }
    
    // æ›´æ–°æœºå™¨äººæ ‡è®°ä½ç½®
     function updateRobotMarker() {
       const marker = document.getElementById('robot-marker');
       
       if (currentMap) {
         // è½¬æ¢ä¸–ç•Œåæ ‡åˆ°Canvasåæ ‡
         // Yåæ ‡è®¡ç®—ä»åŸç‚¹ï¼ˆå·¦ä¸‹è§’ï¼‰å‘ä¸Šå»¶ä¼¸
         const canvasX = offsetX + robotPosition.x * scale;
         const canvasY = offsetY - robotPosition.y * scale;
         
         // è®¾ç½®æ ‡è®°ä½ç½®å’Œæ—‹è½¬è§’åº¦
         marker.style.left = canvasX + 'px';
         marker.style.top = canvasY + 'px';
         marker.style.transform = 'translate(-50%, -50%) rotate(' + (robotPosition.theta * 180 / Math.PI) + 'deg)';
         marker.style.display = 'block';
       } else {
         marker.style.display = 'none';
       }
     }
     
     // æ›´æ–°ç›®æ ‡æ ‡è®°ä½ç½®
     function updateGoalMarker() {
       const marker = document.getElementById('goal-marker');
       
       if (goalPosition && currentMap) {
         // è½¬æ¢ä¸–ç•Œåæ ‡åˆ°Canvasåæ ‡
         // Yåæ ‡è®¡ç®—ä»åŸç‚¹ï¼ˆå·¦ä¸‹è§’ï¼‰å‘ä¸Šå»¶ä¼¸
         const canvasX = offsetX + goalPosition.x * scale;
         const canvasY = offsetY - goalPosition.y * scale;
         
         // è®¾ç½®æ ‡è®°ä½ç½®
         marker.style.left = canvasX + 'px';
         marker.style.top = canvasY + 'px';
         marker.style.display = 'block';
         
         // å¦‚æœæœ‰æœå‘ä¿¡æ¯ï¼Œæ˜¾ç¤ºç®­å¤´
         if (goalPosition.theta !== undefined) {
           // æ¸…é™¤ä¹‹å‰çš„ç®­å¤´
           const existingArrow = document.getElementById('goal-arrow');
           if (existingArrow) {
             existingArrow.remove();
           }
           
           // åˆ›å»ºç®­å¤´å…ƒç´ 
           const arrow = document.createElement('div');
           arrow.id = 'goal-arrow';
           arrow.style.position = 'absolute';
           arrow.style.width = '0';
           arrow.style.height = '0';
           arrow.style.borderLeft = '8px solid transparent';
           arrow.style.borderRight = '8px solid transparent';
           arrow.style.borderBottom = '12px solid #00ff00';
           arrow.style.transform = `translate(-50%, -50%) rotate(${goalPosition.theta}rad)`;
           arrow.style.zIndex = '5';
           arrow.style.left = canvasX + 'px';
           arrow.style.top = canvasY + 'px';
           
           document.getElementById('map-container').appendChild(arrow);
         }
       } else {
         marker.style.display = 'none';
         // æ¸…é™¤ç®­å¤´
         const existingArrow = document.getElementById('goal-arrow');
         if (existingArrow) {
           existingArrow.remove();
         }
       }
     }
    
    // === è¿æ¥ ROS ===
    function connectROS() {
      // ç¡®ä¿ä¸»æœºåæœ‰æ•ˆ
      const hostname = ROSBRIDGE_SERVER_IP || location.hostname || 'localhost';
      const wsUrl = "ws://" + hostname + ":" + ROSBRIDGE_SERVER_PORT;
      
      console.log('æ­£åœ¨è¿æ¥åˆ°ROS Bridge:', wsUrl);
      
      var ros = new ROSLIB.Ros({
        url: wsUrl
      });

      ros.on("connection", function () {
        document.getElementById("conn-status").innerHTML = "âœ… å·²è¿æ¥";
        document.getElementById("conn-status").style.color = "#00ff7f";
        console.log('å·²è¿æ¥åˆ°ROS BridgeæœåŠ¡å™¨');
      });

      ros.on("error", function (error) {
        document.getElementById("conn-status").innerHTML = "âŒ è¿æ¥é”™è¯¯";
        document.getElementById("conn-status").style.color = "red";
        console.error('ROS Bridgeè¿æ¥é”™è¯¯:', error);
      });

      ros.on("close", function () {
        document.getElementById("conn-status").innerHTML = "âš ï¸ å·²æ–­å¼€";
        document.getElementById("conn-status").style.color = "orange";
        console.log('ROS Bridgeè¿æ¥å·²å…³é—­');
      });
      
      // è®¢é˜…åœ°å›¾ä¸»é¢˜
      var mapTopic = new ROSLIB.Topic({
        ros: ros,
        name: MAP_TOPIC,
        messageType: 'nav_msgs/OccupancyGrid'
      });
      
      mapTopic.subscribe(function(mapMsg) {
        console.log('æ”¶åˆ°åœ°å›¾æ•°æ®:', mapMsg.info.width, 'x', mapMsg.info.height, 'åˆ†è¾¨ç‡:', mapMsg.info.resolution);
        
        // æ›´æ–°åœ°å›¾ä¿¡æ¯æ˜¾ç¤º
        document.getElementById('map-info').innerHTML = `åœ°å›¾ä¿¡æ¯ï¼š${mapMsg.info.width}x${mapMsg.info.height}ï¼Œåˆ†è¾¨ç‡ï¼š${mapMsg.info.resolution}m`;
        
        // ä¿å­˜åœ°å›¾æ•°æ®
        currentMap = mapMsg;
        
        // åˆå§‹è°ƒæ•´ç¼©æ”¾å’Œåç§»ï¼Œä½¿åœ°å›¾ä»¥å·¦ä¸‹è§’ä¸ºåŸç‚¹
        const mapWidthMeters = mapMsg.info.width * mapMsg.info.resolution;
        const mapHeightMeters = mapMsg.info.height * mapMsg.info.resolution;
        
        // è®¡ç®—åˆé€‚çš„åˆå§‹ç¼©æ”¾æ¯”ä¾‹
        const scaleX = canvas.width / mapWidthMeters * 0.95; // å¢åŠ åˆå§‹ç¼©æ”¾æ¯”ä¾‹
        const scaleY = canvas.height / mapHeightMeters * 0.95;
        scale = Math.min(scaleX, scaleY);
        
        // è®¾ç½®åŸç‚¹ä¸ºå·¦ä¸‹è§’
        offsetX = 0;
        offsetY = canvas.height;
        
        // ç»˜åˆ¶åœ°å›¾
        drawMap();
      });
      
      // è®¢é˜…LIO-SAMé‡Œç¨‹è®¡ä¸»é¢˜
      var lioSamOdomTopic = new ROSLIB.Topic({
        ros: ros,
        name: LIO_SAM_ODOM_TOPIC,
        messageType: 'nav_msgs/Odometry'
      });
      
      // å››å…ƒæ•°è½¬æ¬§æ‹‰è§’ï¼ˆyawï¼‰çš„å‡½æ•°
      function quaternionToYaw(orientation) {
        // ä½¿ç”¨å››å…ƒæ•°åˆ°æ¬§æ‹‰è§’çš„è½¬æ¢å…¬å¼è®¡ç®—yaw
        const x = orientation.x;
        const y = orientation.y;
        const z = orientation.z;
        const w = orientation.w;
        
        // è®¡ç®—yaw (ç»•Zè½´æ—‹è½¬)
        const siny_cosp = 2 * (w * z + x * y);
        const cosy_cosp = 1 - 2 * (y * y + z * z);
        const yaw = Math.atan2(siny_cosp, cosy_cosp);
        
        return yaw;
      }
      
      lioSamOdomTopic.subscribe(function(odomMsg) {
        // åªæœ‰å½“ä½ç½®æºè®¾ç½®ä¸ºlio_samæ—¶æ‰ä½¿ç”¨è¿™äº›æ•°æ®
        if (positionSource === 'lio_sam') {
          // æ›´æ–°æœºå™¨äººä½ç½®å’Œæœå‘
          robotPosition.x = odomMsg.pose.pose.position.x;
          // æ³¨æ„ï¼šè¿™é‡Œä¿æŒåŸå§‹Yåæ ‡ï¼Œå› ä¸ºåœ¨updateRobotMarkerä¸­å·²ç»å¤„ç†äº†ç¿»è½¬
          robotPosition.y = odomMsg.pose.pose.position.y;
          // æå–æœå‘ä¿¡æ¯
          robotPosition.theta = quaternionToYaw(odomMsg.pose.pose.orientation);
          
          // é‡ç»˜åœ°å›¾ä»¥æ›´æ–°æœºå™¨äººä½ç½®
          drawMap();
        }
      });
      
      // è®¢é˜…AMCLä½ç½®ä¸»é¢˜ï¼ˆä»ç„¶ä¿æŒï¼‰
      var amclPoseTopic = new ROSLIB.Topic({
        ros: ros,
        name: AMCL_POSE_TOPIC,
        messageType: 'geometry_msgs/PoseWithCovarianceStamped'
      });
      
      amclPoseTopic.subscribe(function(poseMsg) {
        // åªæœ‰å½“ä½ç½®æºè®¾ç½®ä¸ºamclæ—¶æ‰ä½¿ç”¨è¿™äº›æ•°æ®
        if (positionSource === 'amcl') {
          // æ›´æ–°æœºå™¨äººä½ç½®å’Œæœå‘
          robotPosition.x = poseMsg.pose.pose.position.x;
          // æ³¨æ„ï¼šè¿™é‡Œä¿æŒåŸå§‹Yåæ ‡ï¼Œå› ä¸ºåœ¨updateRobotMarkerä¸­å·²ç»å¤„ç†äº†ç¿»è½¬
          robotPosition.y = poseMsg.pose.pose.position.y;
          // æå–æœå‘ä¿¡æ¯
          robotPosition.theta = quaternionToYaw(poseMsg.pose.pose.orientation);
          
          // é‡ç»˜åœ°å›¾ä»¥æ›´æ–°æœºå™¨äººä½ç½®
          drawMap();
        }
      });

      // è®¢é˜… slam_toolbox çš„ä½å§¿è¯é¢˜ï¼ˆå…¼å®¹å¤„ç†ï¼‰ï¼›éƒ¨åˆ† slam_toolbox é…ç½®ä¼šå‘å¸ƒ PoseWithCovarianceStamped
      var slamToolboxPoseTopic = new ROSLIB.Topic({
        ros: ros,
        name: SLAM_TOOLBOX_POSE_TOPIC,
        messageType: 'geometry_msgs/PoseWithCovarianceStamped'
      });

      slamToolboxPoseTopic.subscribe(function(poseMsg) {
        // åªæœ‰å½“ä½ç½®æºè®¾ç½®ä¸º slam_toolbox æ—¶æ‰ä½¿ç”¨è¿™äº›æ•°æ®
        if (positionSource === 'slam_toolbox') {
          // æ›´æ–°æœºå™¨äººä½ç½®å’Œæœå‘
          robotPosition.x = poseMsg.pose.pose.position.x;
          robotPosition.y = poseMsg.pose.pose.position.y;
          // æå–æœå‘ä¿¡æ¯
          robotPosition.theta = quaternionToYaw(poseMsg.pose.pose.orientation);
          
          // é‡ç»˜åœ°å›¾ä»¥æ›´æ–°æœºå™¨äººä½ç½®
          drawMap();
        }
      });
      
      return ros;
    }
    
    // å‘å¸ƒåˆå§‹ç‚¹
    function publishInitialPose(x, y, theta = 0) {
      if (!window.ros || !currentMap) {
        showMessage('è¯·å…ˆç¡®ä¿ROSè¿æ¥æ­£å¸¸ä¸”å·²æ”¶åˆ°åœ°å›¾æ•°æ®');
        return;
      }
      
      // ä¿å­˜åˆå§‹ç‚¹ä½ç½®ç”¨äºæ˜¾ç¤º
      initialPosePosition = { x: x, y: y, theta: theta };
      console.log('è®¾ç½®åˆå§‹ç‚¹ä½ç½®:', initialPosePosition);
      
      // åˆ›å»ºåˆå§‹ç‚¹å‘å¸ƒå™¨ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
      if (!window.initialPosePublisher) {
        window.initialPosePublisher = new ROSLIB.Topic({
          ros: window.ros,
          name: INITIAL_POSE_TOPIC,
          messageType: "geometry_msgs/PoseWithCovarianceStamped"
        });
      }
      
      // åˆ›å»ºåˆå§‹ç‚¹æ¶ˆæ¯
      const now = Date.now() / 1000.0;
      var initialPose = new ROSLIB.Message({
        header: {
          stamp: { 
            sec: Math.floor(now), 
            nanosec: Math.floor((now % 1) * 1e9)
          },
          frame_id: "map"
        },
        pose: {
          pose: {
            position: { x: x, y: y, z: 0 },
            orientation: { 
              x: 0, 
              y: 0, 
              z: Math.sin(theta/2), 
              w: Math.cos(theta/2) 
            }
          },
          covariance: [
            0.25, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.25, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.06853892326654787
          ]
        }
      });
      
      // å‘å¸ƒåˆå§‹ç‚¹
      window.initialPosePublisher.publish(initialPose);
      console.log('å‘å¸ƒåˆå§‹ç‚¹åˆ°è¯é¢˜', INITIAL_POSE_TOPIC, ':', initialPose);
      
      // æ›´æ–°åˆå§‹ç‚¹æ ‡è®°
      updateInitialPoseMarker();
      
      // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
      document.getElementById('initial-pose-status').textContent = `å·²è®¾ç½® (${x.toFixed(2)}, ${y.toFixed(2)})`;
      
      // é€€å‡ºåˆå§‹ç‚¹è®¾ç½®æ¨¡å¼
      window.settingInitialPose = false;
      
      showMessage(`åˆå§‹ç‚¹å·²è®¾ç½®ï¼š(${x.toFixed(2)}, ${y.toFixed(2)})`);
    }

    // è®¾ç½®åˆå§‹ç‚¹æ¨¡å¼
    function setInitialPose() {
      if (!window.ros || !currentMap) {
        showMessage('è¯·å…ˆç¡®ä¿ROSè¿æ¥æ­£å¸¸ä¸”å·²æ”¶åˆ°åœ°å›¾æ•°æ®');
        return;
      }
      
      window.settingInitialPose = true;
      canvas.style.cursor = 'crosshair';
      showMessage('è¯·åœ¨åœ°å›¾ä¸Šç‚¹å‡»å¹¶æ‹–åŠ¨æ¥è®¾ç½®åˆå§‹ç‚¹å’Œæ–¹å‘');
      
      // æ›´æ–°æŒ‰é’®çŠ¶æ€
      const button = event.target;
      button.textContent = 'å–æ¶ˆè®¾ç½®';
      button.onclick = cancelSetInitialPose;
    }
    
    // å–æ¶ˆè®¾ç½®åˆå§‹ç‚¹
    function cancelSetInitialPose() {
      window.settingInitialPose = false;
      canvas.style.cursor = 'default';
      showMessage('å·²å–æ¶ˆåˆå§‹ç‚¹è®¾ç½®');
      
      // æ¢å¤æŒ‰é’®çŠ¶æ€
      const button = event.target;
      button.textContent = 'è®¾ç½®åˆå§‹ç‚¹';
      button.onclick = setInitialPose;
    }
    
    // æ˜¾ç¤ºæ¶ˆæ¯å‡½æ•°
    function showMessage(message) {
      // åˆ›å»ºæ¶ˆæ¯æ˜¾ç¤ºå…ƒç´ 
      const messageElement = document.createElement('div');
      messageElement.textContent = message;
      messageElement.style.position = 'fixed';
      messageElement.style.top = '20px';
      messageElement.style.left = '50%';
      messageElement.style.transform = 'translateX(-50%)';
      messageElement.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      messageElement.style.color = 'white';
      messageElement.style.padding = '10px 20px';
      messageElement.style.borderRadius = '5px';
      messageElement.style.zIndex = '1000';
      messageElement.style.fontSize = '14px';
      messageElement.id = 'message-display';
      
      // ç§»é™¤å·²å­˜åœ¨çš„æ¶ˆæ¯å…ƒç´ 
      const existingMessage = document.getElementById('message-display');
      if (existingMessage) {
        existingMessage.remove();
      }
      
      // æ·»åŠ æ–°æ¶ˆæ¯å…ƒç´ 
      document.body.appendChild(messageElement);
      
      // 3ç§’åè‡ªåŠ¨ç§»é™¤æ¶ˆæ¯
      setTimeout(() => {
        if (messageElement.parentNode) {
          messageElement.parentNode.removeChild(messageElement);
        }
      }, 3000);
    }
    
    // æ¸…é™¤åˆå§‹ç‚¹
    function clearInitialPose() {
      initialPosePosition = null;
      updateInitialPoseMarker();
      document.getElementById('initial-pose-status').textContent = 'æœªè®¾ç½®';
      console.log('åˆå§‹ç‚¹å·²æ¸…é™¤');
      showMessage('åˆå§‹ç‚¹å·²æ¸…é™¤');
    }
    
    // æ›´æ–°åˆå§‹ç‚¹æ ‡è®°ä½ç½®
    function updateInitialPoseMarker() {
      const marker = document.getElementById('initial-pose-marker');
      if (!initialPosePosition || !currentMap) {
        marker.style.display = 'none';
        // æ¸…é™¤ç®­å¤´
        const existingArrow = document.getElementById('initial-pose-arrow');
        if (existingArrow) {
          existingArrow.remove();
        }
        return;
      }
      
      // å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºCanvasåæ ‡ï¼ˆåŸç‚¹å·¦ä¸‹è§’ï¼‰
      const canvasX = initialPosePosition.x * scale + offsetX;
      const canvasY = offsetY - initialPosePosition.y * scale;
      
      // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨CanvasèŒƒå›´å†…
      if (canvasX < 0 || canvasX > canvas.width || canvasY < 0 || canvasY > canvas.height) {
        marker.style.display = 'none';
        // æ¸…é™¤ç®­å¤´
        const existingArrow = document.getElementById('initial-pose-arrow');
        if (existingArrow) {
          existingArrow.remove();
        }
        return;
      }
      
      marker.style.left = canvasX + 'px';
      marker.style.top = canvasY + 'px';
      marker.style.display = 'block';
      
      // å¦‚æœæœ‰æœå‘ä¿¡æ¯ï¼Œæ˜¾ç¤ºç®­å¤´
      if (initialPosePosition.theta !== undefined) {
        // æ¸…é™¤ä¹‹å‰çš„ç®­å¤´
        const existingArrow = document.getElementById('initial-pose-arrow');
        if (existingArrow) {
          existingArrow.remove();
        }
        
        // åˆ›å»ºç®­å¤´å…ƒç´ 
        const arrow = document.createElement('div');
        arrow.id = 'initial-pose-arrow';
        arrow.style.position = 'absolute';
        arrow.style.width = '0';
        arrow.style.height = '0';
        arrow.style.borderLeft = '8px solid transparent';
        arrow.style.borderRight = '8px solid transparent';
        arrow.style.borderBottom = '12px solid #ff8800';
        arrow.style.transform = `translate(-50%, -50%) rotate(${initialPosePosition.theta}rad)`;
        arrow.style.zIndex = '6';
        arrow.style.left = canvasX + 'px';
        arrow.style.top = canvasY + 'px';
        
        document.getElementById('map-container').appendChild(arrow);
      }
    }
    
    // å‘å¸ƒç›®æ ‡ç‚¹
    function publishGoal(x, y, yaw = 0) {
      if (!window.ros || !currentMap) {
        showMessage('è¯·å…ˆç¡®ä¿ROSè¿æ¥æ­£å¸¸ä¸”å·²æ”¶åˆ°åœ°å›¾æ•°æ®');
        return;
      }
      
      // ä¿å­˜ç›®æ ‡ä½ç½®ç”¨äºæ˜¾ç¤º
      goalPosition = { x: x, y: y, theta: yaw };
      console.log('è®¾ç½®ç›®æ ‡ä½ç½®:', goalPosition);
      
      // åˆ›å»ºç›®æ ‡å‘å¸ƒå™¨ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
      if (!window.goalPublisher) {
        window.goalPublisher = new ROSLIB.Topic({
          ros: window.ros,
          name: GOAL_TOPIC,
          messageType: "geometry_msgs/PoseStamped"
        });
      }
      
      // åˆ›å»ºç›®æ ‡æ¶ˆæ¯
      const now = Date.now() / 1000.0;
      var goal = new ROSLIB.Message({
        header: {
          stamp: { 
            sec: Math.floor(now), 
            nanosec: Math.floor((now % 1) * 1e9) // ä¿®å¤ï¼šç¡®ä¿nanosecæ˜¯æ•´æ•°ç±»å‹
          },
          frame_id: "map"
        },
        pose: {
          position: { x: x, y: y, z: 0 },
          orientation: { 
            x: 0, 
            y: 0, 
            z: Math.sin(yaw/2), 
            w: Math.cos(yaw/2) 
          }
        }
      });
      
      // å‘å¸ƒç›®æ ‡
      window.goalPublisher.publish(goal);
      console.log('å‘å¸ƒç›®æ ‡ç‚¹åˆ°è¯é¢˜', GOAL_TOPIC, ':', goal);
      
      // æ›´æ–°ç›®æ ‡æ ‡è®°
      updateGoalMarker();
      
      // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
      showMessage(`ç›®æ ‡ç‚¹å·²è®¾ç½®ï¼š(${x.toFixed(2)}, ${y.toFixed(2)})`);
    }
    
    // æ¸…é™¤ç›®æ ‡ç‚¹
    function clearGoal() {
      // ä¿®å¤ï¼šä½¿ç”¨æ›´å¯é çš„æ–¹æ³•å–æ¶ˆå¯¼èˆªç›®æ ‡ï¼Œé¿å…å‘å¸ƒ(0,0)å¯¼è‡´æœºå™¨äººå›åˆ°åŸç‚¹
      if (!window.ros) {
        alert('è¯·å…ˆç¡®ä¿ROSè¿æ¥æ­£å¸¸');
        return;
      }
      
      try {
        console.log('å¼€å§‹æ¸…é™¤å¯¼èˆªç›®æ ‡...');
        
        // æ–¹æ³•1ï¼šå‘å¸ƒé›¶é€Ÿåº¦å‘½ä»¤è®©æœºå™¨äººç«‹å³åœæ­¢ï¼ˆæœ€å¯é çš„æ–¹æ³•ï¼‰
        if (!window.cmdVelPublisher) {
          window.cmdVelPublisher = new ROSLIB.Topic({
            ros: window.ros,
            name: CMD_TOPIC,
            messageType: 'geometry_msgs/Twist'
          });
        }
        
        // å‘é€é›¶é€Ÿåº¦å‘½ä»¤ - è¿ç»­å‘é€å¤šæ¬¡ç¡®ä¿æœºå™¨äººåœæ­¢
        const stopCmd = new ROSLIB.Message({
          linear: { x: 0, y: 0, z: 0 },
          angular: { x: 0, y: 0, z: 0 }
        });
        
        // è¿ç»­å‘é€3æ¬¡åœæ­¢å‘½ä»¤ä»¥ç¡®ä¿æœºå™¨äººåœæ­¢
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            window.cmdVelPublisher.publish(stopCmd);
          }, i * 100);
        }
        console.log('å·²å‘é€åœæ­¢å‘½ä»¤åˆ°', CMD_TOPIC);
        
        // æ–¹æ³•2ï¼šå‘å¸ƒåˆ°é¢„æŠ¢å è¯é¢˜ï¼ˆå¦‚æœç³»ç»Ÿæ”¯æŒï¼‰
        try {
          if (!window.preemptPublisher) {
            window.preemptPublisher = new ROSLIB.Topic({
              ros: window.ros,
              name: "/preempt_teleop",
              messageType: "std_msgs/Empty"
            });
          }
          
          const preemptMsg = new ROSLIB.Message({});
          window.preemptPublisher.publish(preemptMsg);
          console.log('å·²å‘é€é¢„æŠ¢å ä¿¡å·');
        } catch (preemptError) {
          console.warn('é¢„æŠ¢å è¯é¢˜å‘å¸ƒå¤±è´¥ï¼ˆè¿™æ˜¯å¯é€‰çš„ï¼‰:', preemptError);
        }
        
        // æ–¹æ³•3ï¼šå‘å¸ƒåˆ°é€Ÿåº¦é™åˆ¶è¯é¢˜ï¼ˆè®©å¯¼èˆªæ ˆå‡é€Ÿåœæ­¢ï¼‰
        try {
          if (!window.speedLimitPublisher) {
            window.speedLimitPublisher = new ROSLIB.Topic({
              ros: window.ros,
              name: "/speed_limit",
              messageType: "nav2_msgs/SpeedLimit"
            });
          }
          
          const now = Date.now() / 1000.0;
          const speedLimitMsg = new ROSLIB.Message({
            header: {
              stamp: { 
                sec: Math.floor(now), 
                nanosec: Math.floor((now % 1) * 1e9)
              },
              frame_id: "base_link"
            },
            speed_limit: 0.0,  // è®¾ç½®é€Ÿåº¦é™åˆ¶ä¸º0
            percentage: false  // ä½¿ç”¨ç»å¯¹é€Ÿåº¦å€¼
          });
          
          window.speedLimitPublisher.publish(speedLimitMsg);
          console.log('å·²å‘é€é€Ÿåº¦é™åˆ¶å‘½ä»¤');
        } catch (speedError) {
          console.warn('é€Ÿåº¦é™åˆ¶è¯é¢˜å‘å¸ƒå¤±è´¥ï¼ˆè¿™æ˜¯å¯é€‰çš„ï¼‰:', speedError);
        }
        
        // æ–¹æ³•4ï¼šå°è¯•å‘å¸ƒç©ºè·¯å¾„è®©å¯¼èˆªæ ˆåœæ­¢è·Ÿéš
        try {
          if (!window.planPublisher) {
            window.planPublisher = new ROSLIB.Topic({
              ros: window.ros,
              name: "/plan",
              messageType: "nav_msgs/Path"
            });
          }
          
          const now = Date.now() / 1000.0;
          const emptyPathMsg = new ROSLIB.Message({
            header: {
              stamp: { 
                sec: Math.floor(now), 
                nanosec: Math.floor((now % 1) * 1e9)
              },
              frame_id: "map"
            },
            poses: [] // ç©ºè·¯å¾„
          });
          
          window.planPublisher.publish(emptyPathMsg);
          console.log('å·²å‘é€ç©ºè·¯å¾„');
        } catch (planError) {
          console.warn('è·¯å¾„è¯é¢˜å‘å¸ƒå¤±è´¥ï¼ˆè¿™æ˜¯å¯é€‰çš„ï¼‰:', planError);
        }
        
        // éšè—ç›®æ ‡æ ‡è®° - è¿™æ˜¯å…³é”®ï¼šä¸å†å‘å¸ƒ(0,0)ä½œä¸ºæ¸…é™¤ä¿¡å·
        goalPosition = null;
        updateGoalMarker();
        console.log('ç›®æ ‡æ ‡è®°å·²éšè—ï¼ŒgoalPosition è®¾ç½®ä¸º null');
        
        alert('å·²å–æ¶ˆå¯¼èˆªç›®æ ‡å¹¶åœæ­¢æœºå™¨äºº');
        console.log('å¯¼èˆªç›®æ ‡æ¸…é™¤å®Œæˆ - æœºå™¨äººç°åœ¨åº”è¯¥åœæ­¢åœ¨å½“å‰ä½ç½®');
        
      } catch (error) {
        console.error('å–æ¶ˆç›®æ ‡æ—¶å‡ºé”™:', error);
        alert('å–æ¶ˆç›®æ ‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥ROSè¿æ¥');
      }
    }
    
    // åˆ‡æ¢ä½ç½®æº
    function changePositionSource(source) {
      positionSource = source;
      // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
      const statusElement = document.getElementById('position-source-status');
      if (source === 'amcl') {
        statusElement.textContent = 'å½“å‰ï¼šä½¿ç”¨AMCLå®šä½';
      } else if (source === 'slam_toolbox') {
        statusElement.textContent = 'å½“å‰ï¼šä½¿ç”¨SLAM Toolboxå®šä½';
      } else if (source === 'lio_sam') {
        statusElement.textContent = 'å½“å‰ï¼šä½¿ç”¨LIO-SAMé‡Œç¨‹è®¡';
      }
      console.log('ä½ç½®æºå·²åˆ‡æ¢ä¸º:', source);
      // åˆ‡æ¢ä½ç½®æºåï¼Œå¯èƒ½éœ€è¦ç­‰å¾…æ–°æ•°æ®åˆ°æ¥æ‰èƒ½æ›´æ–°æ˜¾ç¤º
    }
    
    // æ›´æ–°åœ°å›¾é¢œè‰²
    function updateMapColor(colorType, colorValue) {
      mapColors[colorType] = colorValue;
      console.log(`å·²æ›´æ–°${colorType}é¢œè‰²ä¸º:`, colorValue);
      // é‡æ–°ç»˜åˆ¶åœ°å›¾ä»¥åº”ç”¨æ–°é¢œè‰²
      drawMap();
    }
    
    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    window.onload = function() {
      // åˆå§‹åŒ–å˜é‡
      window.settingInitialPose = false;
      
      // åˆå§‹åŒ–ä¸»æœºåè¾“å…¥æ¡†
      initHostnameInput();
      
      initCanvas();
      window.ros = connectROS();
      
      // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è®¾ç½®Canvaså¤§å°
      window.addEventListener('resize', function() {
        const mapContainer = document.getElementById('map-container');
        canvas.width = mapContainer.clientWidth;
        canvas.height = mapContainer.clientHeight;
        drawMap();
      });
    };
  </script>
</body>
</html>
